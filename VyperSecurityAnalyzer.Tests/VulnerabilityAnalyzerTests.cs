using VyperSecurityAnalyzer.Analyzer;
using VyperSecurityAnalyzer.Models;

namespace ReentrancyLockVerifier.Tests;

public class VulnerabilityAnalyzerTests
{
    [Theory]
    [InlineData("SafeContract.vy", "./Contracts/SafeContract.vy")]
    public void ShouldNotDetectVulnerabilitiesInSafeContract(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.Empty(report.Single().Vulnerabilities);
    }
    
    [Theory]
    [InlineData("Reentrancy.vy", "./Contracts/Reentrancy.vy")]
    public void ShouldDetectReentrancyIssue(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.NotEmpty(report.Single().Vulnerabilities);
        Assert.True(report.Single().Vulnerabilities.Exists(x => x.Vulnerability == Vulnerability.Reentrancy));
    }
    
    [Theory]
    [InlineData("NoBalanceCheck.vy", "./Contracts/NoBalanceCheck.vy")]
    public void ShouldDetectNoBalanceCheckIssue(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.NotEmpty(report.Single().Vulnerabilities);
        Assert.True(report.Single().Vulnerabilities.Exists(x => x.Vulnerability == Vulnerability.NoBalanceCheck));
    }
    
    [Theory]
    [InlineData("SharedState.vy", "./Contracts/SharedState.vy")]
    public void ShouldDetectSharedStateIssue(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.NotEmpty(report.Single().Vulnerabilities);
        Assert.True(report.Single().Vulnerabilities.Exists(x => x.Vulnerability == Vulnerability.SharedState));
    }
    
    [Theory]
    [InlineData("TxOriginAuthentication.vy", "./Contracts/TxOriginAuthentication.vy")]
    public void ShouldDetectTxOriginAuthenticationIssue(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.NotEmpty(report.Single().Vulnerabilities);
        Assert.True(report.Single().Vulnerabilities.Exists(x => x.Vulnerability == Vulnerability.TxOriginAuthentication));
    }
    
    [Theory]
    [InlineData("UncheckedLowLevelCall.vy", "./Contracts/UncheckedLowLevelCall.vy")]
    public void ShouldDetectUncheckedLowLevelCallIssue(string fileName, string contractPath)
    {
        var analyzer = new VulnerabilityAnalyzer();
        var report = analyzer.AnalyzeFiles(new Dictionary<string, string> { {fileName, contractPath} });
    
        Assert.NotEmpty(report.Single().Vulnerabilities);
        Assert.True(report.Single().Vulnerabilities.Exists(x => x.Vulnerability == Vulnerability.UncheckedLowLevelCall));
    }
    
    // [Theory]
    // [InlineData("./Contracts/NoBalanceCheck.bin")]
    // [InlineData("./Contracts/SharedState.bin")]
    // public void ShouldDetectMissingBalanceCheck(string contractPath)
    // {
    //     var bytecode = File.ReadAllBytes(contractPath);
    //     var analyzer = new ContractAnalyzer();
    //     var vulnerabilities = analyzer.Analyze(bytecode);
    //
    //     Assert.Contains(vulnerabilities, v => 
    //         v.Type is VulnerabilityType.MissingBalanceCheck or VulnerabilityType.SharedStateRaceCondition);
    // }
}