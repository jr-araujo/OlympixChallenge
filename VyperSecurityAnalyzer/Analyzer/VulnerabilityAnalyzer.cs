using VyperSecurityAnalyzer.Models;
using VyperSecurityAnalyzer.Parser;

namespace VyperSecurityAnalyzer.Analyzer;

public class VulnerabilityAnalyzer
{
    public List<(string FileName, List<VulnerabilityReport> Vulnerabilities)> AnalyzeFiles(Dictionary<string, string> files)
    {
        var issuesReport = new List<(string FileName, List<VulnerabilityReport>)>();

        foreach (var kvp in files)
        {
            var fileName = kvp.Key;
            var filePath = kvp.Value;

            issuesReport.Add((fileName, Analyze(filePath)));
        }

        return issuesReport;
    }
    
    private List<VulnerabilityReport> Analyze(string filePath)
    {
        var lines = File.ReadAllLines(filePath);
        var parser = new VyperParser();
        var functions = parser.Parse(lines);
        
        var reports = new List<VulnerabilityReport>();

        foreach (var func in functions)
        {
            var bodyLines = func.BodyLines;
            bool hasSend = bodyLines.Any(l => l.Contains("send(") || l.Contains("call("));
            bool hasBalanceCheck = bodyLines.Any(l =>
                l.Contains("self.balances") && l.Contains(">="));

            // NoBalanceCheck
            if (hasSend && !hasBalanceCheck)
            {
                reports.Add(new VulnerabilityReport
                {
                    FunctionName = func.Name,
                    Vulnerability = Vulnerability.NoBalanceCheck,
                    Description = "Function sends funds without verifying enough balance."
                });
            }

            // SharedState
            for (int i = 0; i < bodyLines.Count; i++)
            {
                var line = bodyLines[i];
                if (line.Contains("send(") || line.Contains("call("))
                {
                    for (int j = i + 1; j < bodyLines.Count; j++)
                    {
                        if (bodyLines[j].Contains("self.") && bodyLines[j].Contains("="))
                        {
                            reports.Add(new VulnerabilityReport
                            {
                                FunctionName = func.Name,
                                Vulnerability = Vulnerability.SharedState,
                                Description = $"State modifying being done after external call. At line {j + 1}."
                            });
                            break;
                        }
                    }
                }
            }

            // Reentrancy
            bool foundSend = false;
            for (int i = 0; i < bodyLines.Count; i++)
            {
                var line = bodyLines[i];
                if (line.Contains("send(") || line.Contains("call("))
                {
                    foundSend = true;
                }
                else if (foundSend && line.Contains("self.") &&
                         (line.Contains("+=") || line.Contains("-=") || line.Contains("=")))
                {
                    reports.Add(new VulnerabilityReport
                    {
                        FunctionName = func.Name,
                        Vulnerability = Vulnerability.Reentrancy,
                        Description = $"State update being done after external sending (Potential reentrancy). At line {i + 1}."
                    });
                    break;
                }
            }

            // UncheckedLowLevelCall
            foreach (var (line, index) in bodyLines.Select((l, i) => (l, i)))
            {
                if ((line.Contains("raw_call") || line.Contains("delegate_call")) &&
                    !line.Contains("if") && !line.Contains("="))
                {
                    reports.Add(new VulnerabilityReport
                    {
                        FunctionName = func.Name,
                        Vulnerability = Vulnerability.UncheckedLowLevelCall,
                        Description = $"Low level call without verifying the return. At linha {index + 1}."
                    });
                }
            }

            // TxOriginAuthentication
            foreach (var (line, index) in bodyLines.Select((l, i) => (l, i)))
            {
                if (line.Contains("tx.origin"))
                {
                    reports.Add(new VulnerabilityReport
                    {
                        FunctionName = func.Name,
                        Vulnerability = Vulnerability.TxOriginAuthentication,
                        Description = $"Usage of tx.origin detected at line {index + 1} (Potential phishing)."
                    });
                }
            }
        }

        return reports;
    }
}